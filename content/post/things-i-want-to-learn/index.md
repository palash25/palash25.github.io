---
title: Things I want to learn/do
date: 2019-11-22
math: false
diagram: true
markup: mmark
image:
  placement: 3
  caption: ''
---

### Theoritical CS / Software in general
- Operating Systems: The only course in my undergrad I regret not paying attention to. The professor was cool and I could have actually spent my time in class learning something worthwhile. Anyway I had started reading up on the subject from this awesome book called [OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/). If anyone is starting out with OS I highly recommend this book.
- Databases
- Networking
- Distributed Systems
- Unikernels
- Fuzz testing

### Cloud Native Tech

Almost everything is deployed and run on the cloud today. The cloud native ecosystem that mostly comes under the CNCF has grown so vast that it is very hard to keep up with all the new projects and changes happening. My first brush with the Cloud Native landscape was this year during the start of the Google Summer of Code application period where I had started contributing to the CoreDNS project. I didn't get selected for GSoC but I did get to work on writing a plugin for CoreDNS under the Community Bridge program. Ever since then I haven't really found the time to explore this space further. Following are the projects that I would like to familiarize myself with as a year and if I can get time maybe contribute to them too.
- Kubernetes
- Prometheus
- TiDB/TiKV
- Jaeger
- Linkered (I could have picked any other service mesh but since Linkered uses both Rust and Go I thought it would be fun to look around the codebase)
- gRPC

Given my familiarity with Go and Rust, contributing shouldn't be that tough.

### Tools
- Docker: Been using this tool for about a year now but still feels like I have barely scratched its surface. Would like to become a power user and then take a deep dive into its internals to see how things really work.

### Programming languages

Ever since I read [Seven Languages In Seven Weeks](https://pragprog.com/book/btlang/seven-more-languages-in-seven-weeks) by Bruce Tate I have been bitten by the "I want to be a polyglot developer" bug. Not because its cool to know several different languages (even though that was my initial motivation) but because each new langauge I learn ends up teaching me a new concept. Right now I can write some Python, Go, Ruby and Rust and I would like that list to grow.

This is a short version (because the actual list is much longer so I am trying to curb my enthusiasm here) of the list of languages that I am currently interested in and would like to pick up:
- [Erlang](https://www.erlang.org/): Just want to know what the fuss is all about the "Let it crash philosophy" and my current interest in distributed systems could lead to some nice projects using Erlang.
- [Clojure](https://clojure.org/): Two reasons for this:
  - Always wanted to pick up a lisp dialect.
  - JVM is unfamiliar territory to me so learning Clojure presents itself as a nice opportunity to get to know that JVM ecosystem.
- [Zig](https://ziglang.org/): Its a systems programming language that aims to be a better C. Still in its early stages. Lots of opportunities to write libraries and reinvent the wheel in this ecosystem.
- [Pony](https://www.ponylang.io/): Its object oriented and actor model (something that I am completely unfamiliar with) based. Same reasons as Zig.
- [Prolog](https://www.swi-prolog.org/): Logic programming is another completely unfamiliar paradigm for me and what better language to get started with this paradigm than the one that influenced Erlang.
- [TLA+](https://www.learntla.com/introduction/): To learn and practice formal verification.
- [Ocaml](https://ocaml.org/): A functional langauge from the ML family. Widely used in the unikernels space. Would be beneficial to know how to read some ocaml code.
